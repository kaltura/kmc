<?xml version="1.0" encoding="utf-8"?>
<mx:LineChart xmlns:mx="http://www.adobe.com/2006/mxml" seriesFilters="{[]}" 
	height="200" dataTipFunction="onDataTip" showDataTips="true" > <!--  -->
	
	<mx:Script>
		<![CDATA[
			import mx.charts.HitData;
			import mx.collections.ArrayCollection;
			import mx.graphics.Stroke;
			private var _minHAxisDate : Date;
			private var _maxHAxisDate : Date;
			private var day : Number = 1000*60*60*24;
			
			[Bindable]
			public var monthGraph:Boolean = false;
			
			/**
			 * override the dataProvider to create the graph points from the rough
			 * @internal 
			 * we don't get any data for days where the value is 0, so we 
			 * first create all needed points with y=0, then go through the data 
			 * we received and replace y values where we have matching x values (dates). 
			 */
			override public function set dataProvider(value:Object):void
			{
				horizontalDateTimeAxis.minimum = null;
				horizontalDateTimeAxis.maximum = null;
					
				var provider : ArrayCollection = new ArrayCollection(); // actual data provider
				
				// fill the 0 points from min to max and not using the build in interpolation
				// first we create all points with correct x and y=0
				if(_maxHAxisDate && _minHAxisDate) {
					var minMaxDays : int = (_maxHAxisDate.time - _minHAxisDate.time)/day;
					for(var j:int=0; j<=minMaxDays; j++) {
						var obj : Object = new Object();
						obj.x = _minHAxisDate.time + (j * day);
						obj.y = 0;
						provider.addItem( obj );
					}
				}
				// if in the value received there is a point matching a point on the graph, 
				// use its value instead of the initial 0.
				if( value && value is ArrayCollection ){
					provider = fixTimeOffsets(provider, value as ArrayCollection);
					var arrCol : ArrayCollection = value as ArrayCollection;
					for(var i:int=0; i<arrCol.length; i++) {
						for(var k:int=0; k<provider.length; k++) {
							var firstDate : Date = new Date( provider[k].x );
							var secondDate : Date = new Date( arrCol[i].x );
							if( firstDate.date == secondDate.date && firstDate.fullYear == secondDate.fullYear && firstDate.month == secondDate.month)
								provider[k] = arrCol[i];
						}
						// make y values Number, fixed to 2 digits after dec point.
						if(String(arrCol[i].y).indexOf('.') != -1)
							arrCol[i].y = Number(arrCol[i].y).toFixed(2);
						else
							arrCol[i].y = Number(arrCol[i].y);	
					}
					
					//if there is only one dot, show the data tip of that dot
					if(provider.length == 1) {
						this.showAllDataTips = true;
						this.showDataTips = false;
					}
					else {
						this.showAllDataTips = false;
						this.showDataTips = true;
					}
				}
				
				super.dataProvider = provider;
			}
			
			/**
			 * there is an offset between the x values of the server data and 
			 * the x value of the mockup data (where the y value is 0).
			 * caculate offset and fix values on the mock data.
			 * @return 	the fixed mockdata array
			 * */
			private function fixTimeOffsets(mockData:ArrayCollection, serverData:ArrayCollection):ArrayCollection {
				
				if(serverData.length <= 0)
					return mockData;
				
				var realDate:Date = new Date(serverData[0].x);
				var mockDate:Date;
				var offset:int;
				var k:int;
				// find the what's offset
				for (k = 0; k < mockData.length; k++) {
					mockDate = new Date(mockData[k].x);
					if (realDate.date == mockDate.date && realDate.fullYear == mockDate.fullYear && realDate.month == mockDate.month) {
						offset = mockData[k].x - serverData[0].x;
						break;
					}
				}
				// fix all mock data
				for (k = 0; k < mockData.length; k++) {
					mockData[k].x -= offset;
				}
				return mockData;
			}
 
            private function onDataTip( hitData:HitData ) : String
            {
            	var s:String;
		        s = new Date(hitData.item.x).toDateString() + "\n";
		        s += hitData.item.y;
		        return s;
            }
            
            public function set minHAxisDate( date : Date ) : void
            {
            	horizontalDateTimeAxis.minimum = date;
            	_minHAxisDate = date;
            }
            
            public function set maxHAxisDate( date : Date ) : void
            {
            	horizontalDateTimeAxis.maximum = date;
            	_maxHAxisDate = date;
            }

		]]>
	</mx:Script>
	
	<!-- Define chart effects -->
	<mx:Stroke id="axis" color="0xb1b1b1" weight="2" />

   <mx:SeriesInterpolate id="rearrangeData" duration="1000" minimumElementDuration="200" elementOffset="0" /> 
	 
	 <mx:horizontalAxisRenderers>
     	<mx:AxisRenderer placement="bottom" axis="{horizontalDateTimeAxis}" axisStroke="{axis}" />
     </mx:horizontalAxisRenderers>
     
	 <mx:horizontalAxis>
    	<mx:DateTimeAxis id="horizontalDateTimeAxis" dataUnits="days" labelUnits="{monthGraph ? 'months' : 'days'}" displayLocalTime="true" />
     </mx:horizontalAxis>

     <mx:verticalAxisRenderers>
     	<mx:AxisRenderer placement="left" axis="{verticalLinearAxis}" axisStroke="{axis}"  />
     </mx:verticalAxisRenderers>
     
     <mx:verticalAxis>
     	<mx:LinearAxis id="verticalLinearAxis" autoAdjust="false" baseAtZero="true"/>
     </mx:verticalAxis>
     
     <mx:series>
     	<mx:LineSeries id="lineSeries" yField="y" xField="x"  showDataEffect="rearrangeData" > <!-- form="curve" -->
	     	<mx:lineStroke>
		        <mx:Stroke color="#9ab40c" weight="3"/>
	        </mx:lineStroke>  
     	</mx:LineSeries>
     </mx:series>
     
</mx:LineChart>
